<!DOCTYPE html>
<html lang="ja" prefix="og: http://ogp.me/ns#">
  <head>
    <meta charset="utf-8">
    <title>スダ宇宙</title>
    <style>
      html, body {
        margin: 0;
        padding: 0;
      }
    </style>
  </head>
  <body>
    <script src="js/three.js"></script>
    <script src="js/OrbitControls.js"></script>
    <script>
      let width = window.innerWidth;
      let height = window.innerHeight;
      let target = document.body;

      let scene;
      let camera;
      let renderer;
      let directional;
      let ambient;
      let controls;
      let point;

      let CAMERA_PARAM = {
        fovy: 90,
        aspect: width / height,
        near: 0.1,
        far: 100.0,
        x: 2.0,
        y:2,
        z: 7.5,
        lookAt: new THREE.Vector3(0.0, 0.0, 0.0)
      };

      let RENDERER_PARAM = {
        clearColor: 0x000000,
        width: width,
        height: height
      };

      let LIGHT_PARAM = {
        directional: {
          positionX: -0.5,
          positionY: 4,
          positionZ: 3
        },
        ambient: {
          positionY: 1
        }
      };

      scene = new THREE.Scene();

      camera = new THREE.PerspectiveCamera(
        CAMERA_PARAM.fovy,
        CAMERA_PARAM.aspect,
        CAMERA_PARAM.near,
        CAMERA_PARAM.far
      );

      camera.position.x = CAMERA_PARAM.x;
      camera.position.y = CAMERA_PARAM.y;
      camera.position.z = CAMERA_PARAM.z;
      camera.lookAt(CAMERA_PARAM.lookAt);

      renderer = new THREE.WebGLRenderer({
        antialias: true
      });
      renderer.setClearColor(new THREE.Color(RENDERER_PARAM.clearColor));
      renderer.setSize(RENDERER_PARAM.width, RENDERER_PARAM.height);
      renderer.shadowMap.enabled = true;

      target.appendChild(renderer.domElement);

      controls = new THREE.OrbitControls(camera, render.domElement);

      directional = new THREE.DirectionalLight(0xffffff);
      ambient = new THREE.AmbientLight(0xffffff, 0.25);

      directional.castShadow = true;

      directional.position.x = LIGHT_PARAM.directional.positionX;
      directional.position.y = LIGHT_PARAM.directional.positionY;
      directional.position.z = LIGHT_PARAM.directional.positionZ;

      ambient.position.y = LIGHT_PARAM.ambient.positionY;

      directional.shadow.mapSize.width = 800;
      directional.shadow.mapSize.height = 800;
      scene.add(directional);
      scene.add(ambient);

      let loader = new THREE.TextureLoader();
      loader.load('images/suda.png', function (texture) {
        createPoints(texture);
        render();
      });

      // createPoints();

      function createPoints (texture) {

        let geometry = new THREE.Geometry();

        let material = new THREE.PointsMaterial({
          size: 0.2,
          vertexColors: true,
          color: 0xffffff,
          map: texture,
          transparent: true
        });

        let maxLength = 1000;

        for (let i = 0; i < maxLength; i++) {
          let pos = getPosition(
            Math.random() * width,
            Math.random() * height,
            Math.random() * width
          );

          let particle = new THREE.Vector3(pos.x, pos.y, pos.z);

          let color = new THREE.Color(0xffffff);
          geometry.vertices.push(particle);
          geometry.colors.push(color);
        }

        point = new THREE.Points(geometry, material);
        scene.add(point);

      }

      function createSprites() {
        let material = new THREE.SpriteMaterial({
          color: 0xffffff
        });

        let maxLength = 1000;

        for (let i = 0; i < maxLength; i++) {
          let sprite = new THREE.Sprite(material);
          let pos = getPosition(
            Math.random() * width,
            Math.random() * height,
            Math.random() * width
          );

          sprite.scale.set(0.1, 0.1, 0.1);
          sprite.position.set(
            pos.x,
            pos.y,
            pos.z
          );

          scene.add(sprite);
        }
      }

      function getPosition(x, y, z) {
        let maxW = width / 2;
        let maxH = height / 2;
        let coefficient = 10;

        return {
          x: (x - maxW) / maxW * coefficient,
          y: (y - maxH) / maxH * coefficient,
          z: (z - maxW) / maxW * coefficient
        }
      };

      render();

      function render() {
        renderer.render(scene, camera);
        requestAnimationFrame(render);
      }
    </script>
  </body>
</html>
